//! TypeScript and JSON Schema generator for Operator types
//!
//! Generates:
//! - shared/types.ts: TypeScript definitions
//! - docs/schemas/*.json: JSON schemas for key types
//!
//! Usage:
//!   cargo run --bin generate_types         # Generate files
//!   cargo run --bin generate_types --check # Check if files are up to date

use std::env;
use std::fs;
use std::path::Path;
use std::process;

use schemars::schema_for;
use ts_rs::TS;

// Import all types that should be exported
use operator::agents::{
    VsCodeActivityResponse, VsCodeActivityState, VsCodeErrorResponse, VsCodeExistsResponse,
    VsCodeHealthResponse, VsCodeLaunchOptions, VsCodeListResponse, VsCodeModelOption,
    VsCodeSendCommandRequest, VsCodeSessionInfo, VsCodeSuccessResponse,
    VsCodeTerminalCreateOptions, VsCodeTerminalState, VsCodeTicketInfo, VsCodeTicketMetadata,
    VsCodeTicketStatus,
};
use operator::api::providers::kanban::{
    JiraAvatarUrls, JiraDescription, JiraIssue, JiraIssueFields, JiraIssueTypeRef, JiraPriority,
    JiraProjectStatus, JiraSearchResponse, JiraStatus, JiraStatusRef, JiraUser,
};
use operator::config::{
    AgentsConfig, ApiConfig, BackstageConfig, BrandingConfig, CollectionPreset, Config, Delegator,
    DelegatorLaunchConfig, DetectedTool, DockerConfig, LaunchConfig, LlmProvider, LlmToolsConfig,
    LoggingConfig, NotificationsConfig, PanelNamesConfig, PathsConfig, QueueConfig, RestApiConfig,
    SkillDirectoriesOverride, TemplatesConfig, ThemeColors, TmuxConfig, ToolCapabilities, UiConfig,
    YoloConfig,
};
use operator::queue::LlmTask;
use operator::rest::dto::{
    CollectionResponse, CreateDelegatorRequest, CreateFieldRequest, CreateIssueTypeRequest,
    CreateStepRequest, DelegatorLaunchConfigDto, DelegatorResponse, DelegatorsResponse,
    FieldResponse, HealthResponse, IssueTypeResponse, IssueTypeSummary, SkillEntry, SkillsResponse,
    StatusResponse, StepResponse, UpdateIssueTypeRequest, UpdateStepRequest,
};
use operator::state::{AgentState, CompletedTicket, State};
use operator::types::{
    AttemptStatus, ExecutionProcess, ProcessStatus, Project, ProjectRepo, RunReason, Session,
    StepAttempt,
};

const HEADER: &str = r#"// =============================================================================
// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// =============================================================================
// Generated by: cargo run --bin generate_types
// Source: src/**/*.rs (types with #[derive(TS)] and #[ts(export)])
//
// To regenerate: cargo run --bin generate_types
// To verify:     cargo run --bin generate_types --check
// =============================================================================

"#;

fn main() {
    let args: Vec<String> = env::args().collect();
    let check_mode = args.iter().any(|a| a == "--check");

    // Generate TypeScript
    let ts_content = generate_typescript();

    // Generate JSON schemas
    let config_schema = generate_json_schema::<Config>("Config");
    let state_schema = generate_json_schema::<State>("State");
    let jira_api_schema = generate_json_schema::<JiraSearchResponse>("JiraSearchResponse");

    if check_mode {
        check_files(&ts_content, &config_schema, &state_schema, &jira_api_schema);
    } else {
        write_files(&ts_content, &config_schema, &state_schema, &jira_api_schema);
    }
}

fn generate_typescript() -> String {
    let mut output = String::from(HEADER);

    // Collect all type declarations
    let decls: Vec<String> = vec![
        // Unified types (src/types/)
        Project::decl(),
        ProjectRepo::decl(),
        StepAttempt::decl(),
        AttemptStatus::decl(),
        ExecutionProcess::decl(),
        ProcessStatus::decl(),
        RunReason::decl(),
        Session::decl(),
        // Config types (src/config.rs)
        Config::decl(),
        AgentsConfig::decl(),
        NotificationsConfig::decl(),
        QueueConfig::decl(),
        PathsConfig::decl(),
        UiConfig::decl(),
        PanelNamesConfig::decl(),
        LaunchConfig::decl(),
        DockerConfig::decl(),
        YoloConfig::decl(),
        TmuxConfig::decl(),
        BackstageConfig::decl(),
        BrandingConfig::decl(),
        ThemeColors::decl(),
        RestApiConfig::decl(),
        LlmToolsConfig::decl(),
        DetectedTool::decl(),
        ToolCapabilities::decl(),
        LlmProvider::decl(),
        SkillDirectoriesOverride::decl(),
        Delegator::decl(),
        DelegatorLaunchConfig::decl(),
        CollectionPreset::decl(),
        TemplatesConfig::decl(),
        LoggingConfig::decl(),
        ApiConfig::decl(),
        // State types (src/state.rs)
        State::decl(),
        AgentState::decl(),
        CompletedTicket::decl(),
        // REST DTOs (src/rest/dto.rs)
        IssueTypeResponse::decl(),
        IssueTypeSummary::decl(),
        CreateIssueTypeRequest::decl(),
        UpdateIssueTypeRequest::decl(),
        FieldResponse::decl(),
        CreateFieldRequest::decl(),
        StepResponse::decl(),
        CreateStepRequest::decl(),
        UpdateStepRequest::decl(),
        CollectionResponse::decl(),
        HealthResponse::decl(),
        StatusResponse::decl(),
        // Skills DTOs
        SkillEntry::decl(),
        SkillsResponse::decl(),
        // Delegator DTOs
        DelegatorResponse::decl(),
        DelegatorsResponse::decl(),
        CreateDelegatorRequest::decl(),
        DelegatorLaunchConfigDto::decl(),
        // Queue types (src/queue/ticket.rs)
        LlmTask::decl(),
        // Jira API types (src/api/providers/kanban/jira.rs)
        JiraSearchResponse::decl(),
        JiraIssue::decl(),
        JiraIssueFields::decl(),
        JiraUser::decl(),
        JiraAvatarUrls::decl(),
        JiraDescription::decl(),
        JiraIssueTypeRef::decl(),
        JiraStatusRef::decl(),
        JiraPriority::decl(),
        JiraProjectStatus::decl(),
        JiraStatus::decl(),
        // VSCode extension types (src/agents/vscode_types.rs)
        VsCodeSessionInfo::decl(),
        VsCodeHealthResponse::decl(),
        VsCodeActivityState::decl(),
        VsCodeTerminalState::decl(),
        VsCodeTerminalCreateOptions::decl(),
        VsCodeSendCommandRequest::decl(),
        VsCodeSuccessResponse::decl(),
        VsCodeExistsResponse::decl(),
        VsCodeActivityResponse::decl(),
        VsCodeListResponse::decl(),
        VsCodeErrorResponse::decl(),
        VsCodeTicketStatus::decl(),
        VsCodeTicketInfo::decl(),
        VsCodeModelOption::decl(),
        VsCodeLaunchOptions::decl(),
        VsCodeTicketMetadata::decl(),
    ];

    // Add export keyword to each declaration
    for decl in decls {
        let exported = if decl.starts_with("type ")
            || decl.starts_with("interface ")
            || decl.starts_with("enum ")
        {
            format!("export {}", decl)
        } else {
            decl
        };
        output.push_str(&exported);
        output.push_str("\n\n");
    }

    output
}

fn generate_json_schema<T: schemars::JsonSchema>(name: &str) -> String {
    let schema = schema_for!(T);
    let mut json = serde_json::to_string_pretty(&schema).unwrap();

    // Add header comment
    let header = format!(
        r#"{{
  "$comment": "AUTO-GENERATED - DO NOT EDIT. Regenerate with: cargo run --bin generate_types",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "{}",
"#,
        name
    );

    // Remove the first { and insert our header
    json = json.replacen("{", &header, 1);

    json
}

fn write_files(ts_content: &str, config_schema: &str, state_schema: &str, jira_api_schema: &str) {
    // Create directories
    fs::create_dir_all("shared").expect("Failed to create shared/ directory");
    fs::create_dir_all("docs/schemas").expect("Failed to create docs/schemas/ directory");

    // Write TypeScript
    let ts_path = Path::new("shared/types.ts");
    fs::write(ts_path, ts_content).expect("Failed to write shared/types.ts");
    println!("Generated: shared/types.ts");

    // Write JSON schemas
    let config_path = Path::new("docs/schemas/config.json");
    fs::write(config_path, config_schema).expect("Failed to write docs/schemas/config.json");
    println!("Generated: docs/schemas/config.json");

    let state_path = Path::new("docs/schemas/state.json");
    fs::write(state_path, state_schema).expect("Failed to write docs/schemas/state.json");
    println!("Generated: docs/schemas/state.json");

    let jira_api_path = Path::new("docs/schemas/jira-api.json");
    fs::write(jira_api_path, jira_api_schema).expect("Failed to write docs/schemas/jira-api.json");
    println!("Generated: docs/schemas/jira-api.json");

    println!("\nType generation complete!");
}

fn check_files(ts_content: &str, config_schema: &str, state_schema: &str, jira_api_schema: &str) {
    let mut outdated = Vec::new();

    // Check TypeScript
    let ts_path = Path::new("shared/types.ts");
    if !ts_path.exists() {
        outdated.push("shared/types.ts (missing)");
    } else {
        let existing = fs::read_to_string(ts_path).unwrap_or_default();
        if existing != ts_content {
            outdated.push("shared/types.ts");
        }
    }

    // Check config schema
    let config_path = Path::new("docs/schemas/config.json");
    if !config_path.exists() {
        outdated.push("docs/schemas/config.json (missing)");
    } else {
        let existing = fs::read_to_string(config_path).unwrap_or_default();
        if existing != config_schema {
            outdated.push("docs/schemas/config.json");
        }
    }

    // Check state schema
    let state_path = Path::new("docs/schemas/state.json");
    if !state_path.exists() {
        outdated.push("docs/schemas/state.json (missing)");
    } else {
        let existing = fs::read_to_string(state_path).unwrap_or_default();
        if existing != state_schema {
            outdated.push("docs/schemas/state.json");
        }
    }

    // Check Jira API schema
    let jira_api_path = Path::new("docs/schemas/jira-api.json");
    if !jira_api_path.exists() {
        outdated.push("docs/schemas/jira-api.json (missing)");
    } else {
        let existing = fs::read_to_string(jira_api_path).unwrap_or_default();
        if existing != jira_api_schema {
            outdated.push("docs/schemas/jira-api.json");
        }
    }

    if outdated.is_empty() {
        println!("All generated files are up to date.");
    } else {
        eprintln!("The following files are out of date:");
        for file in &outdated {
            eprintln!("  - {}", file);
        }
        eprintln!("\nRun `cargo run --bin generate_types` to regenerate.");
        process::exit(1);
    }
}
