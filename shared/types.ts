// =============================================================================
// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// =============================================================================
// Generated by: cargo run --bin generate_types
// Source: src/**/*.rs (types with #[derive(TS)] and #[ts(export)])
//
// To regenerate: cargo run --bin generate_types
// To verify:     cargo run --bin generate_types --check
// =============================================================================

export type Project = { 
/**
 * Unique identifier
 */
id: string, 
/**
 * Human-readable project name
 */
name: string, 
/**
 * Filesystem path to the project root
 */
path: string, 
/**
 * Associated git repositories (can be multiple for monorepos)
 */
repos: Array<ProjectRepo>, 
/**
 * Default branch for merging (e.g., "main", "master")
 */
default_branch: string | null, 
/**
 * Path to the AI context file (CLAUDE.md, GEMINI.md, etc.)
 */
ai_context_path: string | null, 
/**
 * Backstage taxonomy kind (tier 1-5)
 */
kind: string | null, 
/**
 * Tags for categorization
 */
tags: Array<string>, 
/**
 * Development server startup command
 */
dev_script: string | null, 
/**
 * Working directory for dev script execution
 */
dev_script_working_dir: string | null, 
/**
 * Default working directory for AI agents
 */
default_agent_working_dir: string | null, 
/**
 * Setup script to run before agent execution
 */
setup_script: string | null, 
/**
 * Cleanup script to run after agent execution
 */
cleanup_script: string | null, 
/**
 * Link to shared organizational project
 */
remote_project_id: string | null, created_at: string, updated_at: string, };

export type ProjectRepo = { 
/**
 * Unique identifier for this repo association
 */
id: string, 
/**
 * Absolute path to the repository root
 */
path: string, 
/**
 * Whether this is the primary repo for the project
 */
is_primary: boolean, 
/**
 * Setup script to run when creating worktrees for this repo
 */
setup_script: string | null, 
/**
 * Cleanup script to run when deleting worktrees
 */
cleanup_script: string | null, 
/**
 * Files to copy into worktrees (e.g., .env files)
 */
copy_files: Array<string>, };

export type StepAttempt = { 
/**
 * Unique identifier for this attempt
 */
id: string, 
/**
 * Parent ticket ID (e.g., "FEAT-1234")
 */
ticket_id: string, 
/**
 * Which step this attempt is executing (e.g., "plan", "implement", "test")
 */
step_name: string, 
/**
 * Project name this attempt belongs to
 */
project: string, 
/**
 * Git branch for this attempt (e.g., "feat/abc123-add-login")
 */
branch: string, 
/**
 * Target branch to merge into (e.g., "main")
 */
target_branch: string, 
/**
 * Path to isolated git worktree (if using worktree isolation)
 */
worktree_path: string | null, 
/**
 * Whether the worktree has been cleaned up
 */
worktree_deleted: boolean, 
/**
 * Which LLM tool is executing (e.g., "claude", "gemini", "codex")
 */
executor: string, 
/**
 * Executor model override (e.g., "claude-sonnet-4-20250514")
 */
executor_model: string | null, 
/**
 * Current session ID for conversational continuity
 */
session_id: string | null, 
/**
 * Launch mode: "default", "yolo", "docker", "docker-yolo"
 */
launch_mode: string | null, 
/**
 * Current status of this attempt
 */
status: AttemptStatus, 
/**
 * Whether this attempt requires human pairing (SPIKE/INV modes)
 */
paired: boolean, 
/**
 * Tmux session name (for Operator's terminal-based execution)
 */
tmux_session: string | null, 
/**
 * Hash of last captured terminal content (for change detection)
 */
content_hash: string | null, 
/**
 * Pull request URL if created
 */
pr_url: string | null, 
/**
 * PR number for API tracking
 */
pr_number: bigint | null, 
/**
 * GitHub repo in format "owner/repo"
 */
github_repo: string | null, 
/**
 * Current PR status ("open", "approved", "changes_requested", "merged", "closed")
 */
pr_status: string | null, 
/**
 * When setup completed (worktree created, scripts run)
 */
setup_completed_at: string | null, 
/**
 * Last activity timestamp
 */
last_activity: string, 
/**
 * Last time terminal content changed (for hung detection)
 */
last_content_change: string | null, created_at: string, updated_at: string, };

export type AttemptStatus = "pending" | "setting" | "running" | "awaitinginput" | "inreview" | "completed" | "failed" | "cancelled" | "orphaned";

export type ExecutionProcess = { 
/**
 * Unique identifier
 */
id: string, 
/**
 * Parent attempt ID
 */
attempt_id: string, 
/**
 * Why this process was spawned
 */
run_reason: RunReason, 
/**
 * Action chain configuration (for sequential execution)
 */
executor_action: JsonValue | null, 
/**
 * Git HEAD before execution started
 */
before_head_commit: string | null, 
/**
 * Git HEAD after execution completed
 */
after_head_commit: string | null, 
/**
 * Current process status
 */
status: ProcessStatus, 
/**
 * Process exit code (if completed)
 */
exit_code: number | null, 
/**
 * Whether this process is excluded from the timeline (e.g., after retry)
 */
dropped: boolean, started_at: string, completed_at: string | null, };

export type ProcessStatus = "running" | "completed" | "failed" | "killed";

export type RunReason = "setupscript" | "codingagent" | "cleanup" | "followup";

export type Session = { 
/**
 * Unique identifier
 */
id: string, 
/**
 * Parent attempt ID
 */
attempt_id: string, 
/**
 * Tmux session name for terminal-based execution
 */
tmux_session_name: string | null, 
/**
 * Hash of terminal content for change detection
 */
content_hash: string | null, 
/**
 * Agent's internal session ID (e.g., Claude's conversation ID)
 */
agent_session_id: string | null, 
/**
 * Summary extracted from message store
 */
summary: string | null, created_at: string, updated_at: string, };

export type Config = { 
/**
 * List of projects operator can assign work to
 */
projects: Array<string>, agents: AgentsConfig, notifications: NotificationsConfig, queue: QueueConfig, paths: PathsConfig, ui: UiConfig, launch: LaunchConfig, templates: TemplatesConfig, api: ApiConfig, logging: LoggingConfig, tmux: TmuxConfig, llm_tools: LlmToolsConfig, backstage: BackstageConfig, rest_api: RestApiConfig, git: GitConfig, 
/**
 * Kanban provider configuration for syncing issues from Jira, Linear, etc.
 */
kanban: KanbanConfig, };

export type AgentsConfig = { max_parallel: number, cores_reserved: number, health_check_interval: bigint, 
/**
 * Timeout in seconds for each agent generation (default: 300 = 5 min)
 */
generation_timeout_secs: bigint, 
/**
 * Interval in seconds between ticket-session syncs (default: 60)
 */
sync_interval: bigint, 
/**
 * Maximum seconds a step can run before timing out (default: 1800 = 30 min)
 */
step_timeout: bigint, 
/**
 * Seconds of tmux silence before considering agent awaiting input (default: 30)
 */
silence_threshold: bigint, };

export type NotificationsConfig = { 
/**
 * Global enabled flag for all notifications
 */
enabled: boolean, 
/**
 * OS notification configuration
 */
os: OsNotificationConfig, 
/**
 * Single webhook configuration (for simple setups)
 */
webhook: WebhookConfig | null, 
/**
 * Multiple webhook configurations
 */
webhooks: Array<WebhookConfig>, };

export type QueueConfig = { auto_assign: boolean, priority_order: Array<string>, poll_interval_ms: bigint, };

export type PathsConfig = { tickets: string, projects: string, state: string, 
/**
 * Base directory for per-ticket worktrees (default: ~/.operator/worktrees)
 */
worktrees: string, };

export type UiConfig = { refresh_rate_ms: bigint, completed_history_hours: bigint, summary_max_length: number, panel_names: PanelNamesConfig, };

export type PanelNamesConfig = { queue: string, agents: string, awaiting: string, completed: string, };

export type LaunchConfig = { confirm_autonomous: boolean, confirm_paired: boolean, launch_delay_ms: bigint, 
/**
 * Docker execution configuration
 */
docker: DockerConfig, 
/**
 * YOLO (auto-accept) mode configuration
 */
yolo: YoloConfig, };

export type DockerConfig = { 
/**
 * Whether docker mode option is available in launch dialog
 */
enabled: boolean, 
/**
 * Docker image to use (required if enabled)
 */
image: string, 
/**
 * Additional docker run arguments
 */
extra_args: Array<string>, 
/**
 * Container mount path for the project (default: /workspace)
 */
mount_path: string, 
/**
 * Environment variables to pass through to the container
 */
env_vars: Array<string>, };

export type YoloConfig = { 
/**
 * Whether YOLO mode option is available in launch dialog
 */
enabled: boolean, };

export type TmuxConfig = { 
/**
 * Whether custom tmux config has been generated
 */
config_generated: boolean, };

export type BackstageConfig = { 
/**
 * Whether Backstage integration is enabled
 */
enabled: boolean, 
/**
 * Port for the Backstage server
 */
port: number, 
/**
 * Auto-start Backstage server when TUI launches
 */
auto_start: boolean, 
/**
 * Subdirectory within state_path for Backstage installation
 */
subpath: string, 
/**
 * Subdirectory within backstage path for branding customization
 */
branding_subpath: string, 
/**
 * Base URL for downloading backstage-server binary
 */
release_url: string, 
/**
 * Optional local path to backstage-server binary
 * If set, this is used instead of downloading from release_url
 */
local_binary_path: string | null, 
/**
 * Branding and theming configuration
 */
branding: BrandingConfig, };

export type BrandingConfig = { 
/**
 * App title shown in header
 */
app_title: string, 
/**
 * Organization name
 */
org_name: string, 
/**
 * Path to logo SVG (relative to branding path)
 */
logo_path: string | null, 
/**
 * Theme colors (uses Operator defaults if not set)
 */
colors: ThemeColors, };

export type ThemeColors = { 
/**
 * Primary/accent color (default: salmon #cc6c55)
 */
primary: string, 
/**
 * Secondary color (default: dark teal #114145)
 */
secondary: string, 
/**
 * Accent/highlight color (default: cream #f4dbb7)
 */
accent: string, 
/**
 * Warning/error color (default: coral #d46048)
 */
warning: string, 
/**
 * Muted text color (default: darker salmon #8a4a3a)
 */
muted: string, };

export type RestApiConfig = { 
/**
 * Whether the REST API is enabled
 */
enabled: boolean, 
/**
 * Port for the REST API server
 */
port: number, 
/**
 * CORS allowed origins (empty = allow all)
 */
cors_origins: Array<string>, };

export type LlmToolsConfig = { 
/**
 * Detected CLI tools (populated on first startup)
 */
detected: Array<DetectedTool>, 
/**
 * Available {tool, model} pairs for launching tickets
 * Built from detected tools + their model aliases
 */
providers: Array<LlmProvider>, 
/**
 * Whether detection has been completed
 */
detection_complete: boolean, };

export type DetectedTool = { 
/**
 * Tool name (e.g., "claude")
 */
name: string, 
/**
 * Path to the binary
 */
path: string, 
/**
 * Version string
 */
version: string, 
/**
 * Available model aliases (e.g., ["opus", "sonnet", "haiku"])
 */
model_aliases: Array<string>, 
/**
 * Command template with {{model}}, {{session_id}}, {{prompt_file}} placeholders
 */
command_template: string, 
/**
 * Tool capabilities
 */
capabilities: ToolCapabilities, 
/**
 * CLI flags for YOLO (auto-accept) mode
 */
yolo_flags: Array<string>, };

export type ToolCapabilities = { 
/**
 * Whether the tool supports session continuity via UUID
 */
supports_sessions: boolean, 
/**
 * Whether the tool can run in headless/non-interactive mode
 */
supports_headless: boolean, };

export type LlmProvider = { 
/**
 * CLI tool name (e.g., "claude", "codex", "gemini")
 */
tool: string, 
/**
 * Model alias or name (e.g., "opus", "sonnet", "gpt-4.1")
 */
model: string, 
/**
 * Optional display name for UI (e.g., "Claude Opus", "Codex High")
 */
display_name: string | null, 
/**
 * Additional CLI flags for this provider (e.g., ["--dangerously-skip-permissions"])
 */
flags: Array<string>, 
/**
 * Environment variables to set when launching
 */
env: { [key in string]?: string }, 
/**
 * Whether this provider requires approval gates
 */
approvals: boolean, 
/**
 * Whether to run in plan-only mode
 */
plan_only: boolean, 
/**
 * Reasoning effort level (Codex: "low", "medium", "high")
 */
reasoning_effort: string | null, 
/**
 * Sandbox mode (Codex: "danger-full-access", "workspace-write")
 */
sandbox: string | null, };

export type CollectionPreset = "simple" | "dev_kanban" | "devops_kanban" | "custom";

export type TemplatesConfig = { 
/**
 * Named preset for issue type collection
 * Options: simple, dev_kanban, devops_kanban, custom
 */
preset: CollectionPreset, 
/**
 * Custom issuetype collection (only used when preset = custom)
 * List of issue type keys: TASK, FEAT, FIX, SPIKE, INV
 */
collection: Array<string>, 
/**
 * Active collection name (overrides preset if set)
 * Can be a builtin preset name or a user-defined collection
 */
active_collection: string | null, };

export type LoggingConfig = { 
/**
 * Log level filter (trace, debug, info, warn, error)
 */
level: string, 
/**
 * Whether to log to file in TUI mode (false = stderr for debugging)
 */
to_file: boolean, };

export type ApiConfig = { 
/**
 * Interval in seconds between PR status checks (default: 60)
 */
pr_check_interval_secs: bigint, 
/**
 * Interval in seconds between rate limit checks (default: 300)
 */
rate_limit_check_interval_secs: bigint, 
/**
 * Show warning when rate limit remaining is below this percentage (default: 0.2)
 */
rate_limit_warning_threshold: number, };

export type State = { paused: boolean, agents: Array<AgentState>, completed: Array<CompletedTicket>, 
/**
 * Per-project LLM usage statistics
 */
project_llm_stats: { [key in string]?: ProjectLlmStats }, 
/**
 * Per-project issue type collection preferences (project_name -> collection_name)
 */
project_collection_prefs: { [key in string]?: string }, };

export type AgentState = { id: string, ticket_id: string, ticket_type: string, project: string, status: string, started_at: string, last_activity: string, last_message: string | null, paired: boolean, 
/**
 * The tmux session name for this agent (for recovery)
 */
session_name: string | null, 
/**
 * Hash of the last captured pane content (for change detection)
 */
content_hash: string | null, 
/**
 * Current step in the ticket workflow (e.g., "plan", "implement", "test")
 */
current_step: string | null, 
/**
 * When the current step started (for timeout detection)
 */
step_started_at: string | null, 
/**
 * Last time content changed in the session (for hung detection)
 */
last_content_change: string | null, 
/**
 * PR URL if created during "pr" step
 */
pr_url: string | null, 
/**
 * PR number for GitHub API tracking
 */
pr_number: bigint | null, 
/**
 * GitHub repo in format "owner/repo"
 */
github_repo: string | null, 
/**
 * Last known PR status ("open", "approved", "changes_requested", "merged", "closed")
 */
pr_status: string | null, 
/**
 * Completed steps for this ticket
 */
completed_steps: Array<string>, 
/**
 * LLM tool used (e.g., "claude", "gemini", "codex")
 */
llm_tool: string | null, 
/**
 * Launch mode: "default", "yolo", "docker", "docker-yolo"
 */
launch_mode: string | null, 
/**
 * Review state for awaiting_input agents
 * Values: "pending_plan", "pending_visual", "pending_pr_creation", "pending_pr_merge"
 */
review_state: string | null, 
/**
 * Server process ID for visual review cleanup (if applicable)
 */
dev_server_pid: number | null, 
/**
 * Path to the git worktree for this ticket (per-ticket isolation)
 */
worktree_path: string | null, };

export type CompletedTicket = { ticket_id: string, ticket_type: string, project: string, summary: string, completed_at: string, pr_url: string | null, output_tickets: Array<string>, };

export type IssueTypeResponse = { key: string, name: string, description: string, mode: string, glyph: string, color: string | null, project_required: boolean, source: string, fields: Array<FieldResponse>, steps: Array<StepResponse>, };

export type IssueTypeSummary = { key: string, name: string, description: string, mode: string, glyph: string, source: string, step_count: number, };

export type CreateIssueTypeRequest = { key: string, name: string, description: string, mode: string, glyph: string, color: string | null, project_required: boolean, fields: Array<CreateFieldRequest>, steps: Array<CreateStepRequest>, };

export type UpdateIssueTypeRequest = { name: string | null, description: string | null, mode: string | null, glyph: string | null, color: string | null, project_required: boolean | null, fields: Array<CreateFieldRequest> | null, steps: Array<CreateStepRequest> | null, };

export type FieldResponse = { name: string, description: string, field_type: string, required: boolean, default: string | null, options: Array<string>, placeholder: string | null, max_length: number | null, user_editable: boolean, };

export type CreateFieldRequest = { name: string, description: string, field_type: string, required: boolean, default: string | null, options: Array<string>, placeholder: string | null, max_length: number | null, user_editable: boolean, };

export type StepResponse = { name: string, display_name: string | null, prompt: string, outputs: Array<string>, allowed_tools: Array<string>, 
/**
 * Type of review required: "none", "plan", "visual", "pr"
 */
review_type: string, next_step: string | null, permission_mode: string, };

export type CreateStepRequest = { name: string, display_name: string | null, prompt: string, outputs: Array<string>, allowed_tools: Array<string>, 
/**
 * Type of review required: "none", "plan", "visual", "pr"
 */
review_type: string, next_step: string | null, permission_mode: string, };

export type UpdateStepRequest = { display_name: string | null, prompt: string | null, outputs: Array<string> | null, allowed_tools: Array<string> | null, 
/**
 * Type of review required: "none", "plan", "visual", "pr"
 */
review_type: string | null, next_step: string | null, permission_mode: string | null, };

export type CollectionResponse = { name: string, description: string, types: Array<string>, is_active: boolean, };

export type HealthResponse = { status: string, version: string, };

export type StatusResponse = { status: string, version: string, issuetype_count: number, collection_count: number, active_collection: string, };

export type LlmTask = { 
/**
 * LLM task ID (e.g., Claude delegate mode task UUID)
 */
id: string | null, 
/**
 * LLM task status: "open" or "resolved"
 */
status: string | null, 
/**
 * List of task IDs that must resolve before this task
 */
blocked_by: Array<string>, };

export type JiraSearchResponse = { 
/**
 * List of issues matching the JQL query
 */
issues: Array<JiraIssue>, };

export type JiraIssue = { 
/**
 * Internal Jira issue ID
 */
id: string, 
/**
 * Issue key (e.g., "PROJ-123")
 */
key: string, 
/**
 * Issue fields containing summary, status, etc.
 */
fields: JiraIssueFields, };

export type JiraIssueFields = { 
/**
 * Issue summary/title
 */
summary: string, 
/**
 * Issue description in ADF format
 */
description: JiraDescription | null, 
/**
 * Issue type (Bug, Story, Task, etc.)
 */
issuetype: JiraIssueTypeRef, 
/**
 * Current workflow status
 */
status: JiraStatusRef, 
/**
 * Assigned user (if any)
 */
assignee: JiraUser | null, 
/**
 * Issue priority (if set)
 */
priority: JiraPriority | null, };

export type JiraUser = { 
/**
 * Atlassian account ID (e.g., "5e3f7acd9876543210abcdef")
 */
accountId: string, 
/**
 * User's display name
 */
displayName: string, 
/**
 * User's email address (may be hidden by privacy settings)
 */
emailAddress: string | null, 
/**
 * Avatar URLs in various sizes
 */
avatarUrls: JiraAvatarUrls | null, };

export type JiraAvatarUrls = { 
/**
 * 48x48 pixel avatar URL
 */
"48x48": string | null, };

export type JiraDescription = { 
/**
 * ADF content nodes - parsed to extract plain text
 */
content: Array<JsonValue> | null, };

export type JiraIssueTypeRef = { 
/**
 * Issue type name (e.g., "Bug", "Story", "Task")
 */
name: string, };

export type JiraStatusRef = { 
/**
 * Status name (e.g., "To Do", "In Progress", "Done")
 */
name: string, };

export type JiraPriority = { 
/**
 * Priority name (e.g., "Highest", "High", "Medium", "Low", "Lowest")
 */
name: string, };

export type JiraProjectStatus = { 
/**
 * List of statuses available for this issue type
 */
statuses: Array<JiraStatus>, };

export type JiraStatus = { 
/**
 * Status name (e.g., "To Do", "In Progress", "Done")
 */
name: string, };

